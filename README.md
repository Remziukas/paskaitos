# ![](https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/30px-ISO_C%2B%2B_Logo.svg.png) Objektinio programavimo paskaitų medžiaga  

## SVARBU: Info dėl reikalavimų egzaminui

- Egzaminui reikia (pagal aprašytus reikalavimus ir besilaikant nurodytų terminų) būti pasidarius: __2-ą, 3-ą (iki `v1.0`), 4-ą ir 5-ą užduotis__.
- Kaip (šiandien) akcentavau per teorinę paskaitą, atsiskaitymas bus iš dviejų dalių: viešasis, t.y. 3-5 min. pitch'as prieš auditoriją, kurio metu Jūsų tikslas yra pristatyti (pasidalinti su kolegomis) 1-2 "cool dalykėliais" (sukurta funkcija, algoritmu, ciklu, C++ sintaksės niuansais ir pan.) kuriuos išmokote/sužinojote/atradote bedarydami tas užduotis ir kas galbūt būtų naudinga žinoti ir kitiems. Tam nereikia daryti jokių papildomų skaidrių. Tiesiog kiekvienos atitinkamos užduoties `README.md` failą papildykite tais "cool dalykėliais" ir paskaitos metu pristatysite kolegoms juos - programos paleidinėti nereikės - programų veikimą patikrinsiu per pratybas.
- Egzamino užduotis bus iš paveldėjimo (_inheritance_) tematikos (medžiagos tam bus užtektinai - ketvirtadienio paskaita bus ir vėl skirta vien tam, o ir esu nurodęs literatūrą kurią galite papildomai pavartyti, jeigu jaučiatės netvirtai). Pati užduotis bus tęsinys 3-ojo darbo. __Ją atlikti bus nebūtina, jeigu visas užduotis iki 5-osios darėte savarankiškai ir kruopščiai ir mano siūlomas galutinis balas Jus tenkina!__ 
- Jeigu galutinis balas netenkina (arba man kils dvejonių, kad užduotis darėte nesavarankiškai), tuomet auditorijoje reikės atlikti egzamino užduotį ir tokiu būdu bus galima galutinį balą **pasikelti**, o taip pat įgyti daugiau praktinės patirties įsisavinant paveldėjimo koncepsiją. 
- P.s. Jeigu kažkuri suformuluota užduotis (dalis užduoties) būtų per sunki, t.y. visi ar beveik visi neįveiktų jos, tuomet aš jos tikrai neįtrauksiu į vertinimo procesą. Tačiau universitete niekada neturėtų būti taip, kad kiekvienai užduočiai Jums būtų parodoma kaip kažką panašaus daryti. Mūsų tikslas ugdyti Jūsų savarankiškumą ir asmeniškumą! Automatiškume žmonės su robotais nepakonkuruos :)
- P.p.s. mes dar turime dvi teorines paskaitas kitą savaitę: dalį jų skirsime pitch'inimui, kuris manau yra labai naudingas, nes bent dalis iš Jūsų darydami užduotis sužinojote daug naudingų dalykų, o jais pasidalinti ir pasididžiuoti  prieš kolegas tikrai galima :smile: ir reikia! Kitą dalį, galiu skirti pagal Jūsų poreikius, t.y. informuokite ketvirtadienį ką iš Objektinio Programavimo teorijos dar norėtumėte geriau/giliau ar naujai sužinoti atsižvelgus į dalyko modulį.


## SVARBU: Info dėl užduočių struktūros ir kitų susijusių dalykų

> Gavau klausimų/prieštaravimų, o kaip "_unit testing'as_" ir kiti pan. dalykai susiję su Objektinio Programavimo kursu? 

Pagal mane, jie susiję lygiai taip pat, kaip ir įvairūs IDE (CLion, Visual Studio, Codeblocks ir t.t.), grafiniai/komandinės eilutės debugeriai, įvairūs kompiliatoriai, jų flag'ai, warning'ų/error žinučių skaitymas ir bandymas jas suprasti, make/cmake failai ir jų paskirtis, revizijų kontrolės sistemos ir dar krūva kitų dalykų - tai yra dalis efektyvios programavimo aplinkos (_environmet_) kuris yra būtinas, jeigu jau pasirinkai programuotojo kelią. Kam kyla dvejonių, ar tikrai taip, pasiklauskite savo jau dirbančių kolegų arba tiesiog pavartykite darbo skelbimus, kuriuose ieško bent kiek "padoresnių" programerių. Galiausiai, atėjęs į Jūsų grupę pamačiau, kas buvo, kai mokėtės "tik procedūrinio programavimo" - to pasekoje dalis nežinojote, kas tas preprocesorius, kas tas kompiliatorius, linkeris ar net kaip projektas susideda iš kelių (header) failų? Ar tai yra procedūrinio programavimo dalis? Tikrai ne! Bet tai yra bendrai programavimo (nesigilinant procedūrinis, funkcinis, objektinis) labai svarbi dalis, be kurios gero supratimo neįmanoma kurti efektyvių programų. 

Jeigu dar kyla abejonių, tuomet leisiu egzaminą užduotį atlikti Notepad aplinkoje, nesinaudojant jokiais IDE, kompiliatoriaisi, debugeriais, make failais, o tik _pure_ Objektinio Programavimo žiniomis. Tuomet pamatysim, kaip patogu rašyti kodą be sintaksės palengvinimų, kompiliatoriaus naudojimo, debuggerio pagalbos ar kaip iš viso pasidaryti galutinį exe failą iš kelių Jūsų sukurtų cpp/h failų. Tuomet ir pamatysim ar visa to reikia norint pradžiai bent jau kurti Objektiškai Orientuotas programas, efektyvumą palikus visai nuošalėje.

# [Wiki](https://github.com/objprog/paskaitos/wiki) meniu

<a href="https://github.com/objprog/praktika/wiki"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/18/ISO_C%2B%2B_Logo.svg/1200px-ISO_C%2B%2B_Logo.svg.png" width="20"></a> __praktinės užduotys:__

| [1-oji užduotis](https://github.com/objprog/paskaitos/wiki/1-oji-užduotis) | [2-oji užduotis](https://github.com/objprog/paskaitos/wiki/2-oji-užduotis)  | [3-oji užduotis](https://github.com/objprog/paskaitos/wiki/3-oji-užduotis) | [4-oji užduotis](https://github.com/objprog/paskaitos/wiki/4-oji-užduotis) | [5-oji užduotis](https://github.com/objprog/paskaitos/wiki/5-oji-užduotis) |
|:-------------:|:-------------:|:-------------:|:-------------:|:-------------:|

# OOP kurso temos (pagal dalyko modulį)

| Temų pavadinimai            | Medžiaga skaidrėse ir GitHub wiki |
|:----------------------------|:----------------------------------|
| 1. Kurso apžvalga, C++ standartai, kas yra objektiškai orientuotas programavimas (OOP)?, objekto koncepcija, pažintis su programavimo aplinka: kompiliatorių ir įrankių (IDE) apžvalga, versijų kontrolės sistemos (git), make/cmake įrankiai, unit-testai. | <ul><li> [slides/oop-ivadas.pdf](https://github.com/objprog/paskaitos/blob/master/slides/oop-ivadas.pdf) </li><li> [Git pagrindai](https://github.com/objprog/git-pagrindai) </li></ul> | 
| 2. Baziniai duomenų tipai, tipų transformacija, „l-values“ ir „r-values“, rodyklės ir nuorodos, „l-values“ (konstantinės) nuorodos, dinaminis atminties valdymas, aritmetika su adresais. Funkcijų persidengimas, direktyvos. Įvesties ir išvesties operatoriai. | <ul><li> [slides/L-values-r-values-and-references.pdf](https://github.com/objprog/paskaitos/blob/master/slides/L-values-r-values-and-references.pdf)</li></ul> |
| 3. Vartotojo tipai, klasės ir objektai, struktūros, konstruktoriai, pagrindinis konstruktorius, destruktoriai, C++ “garbage collector” - pagal „RAII“ paradigmą, objektiškai orientuotas dizainas, interfeisai, inkapsuliavimas, matomumo kontrolė | <ul><li> [slides/vartotoju-tipai-klases.pdf](https://github.com/objprog/paskaitos/blob/master/slides/vartotoju-tipai-klases.pdf) </li></ul> |
| 4. Operatorių persidengimas, įvesties/išvesties operatoriai, operatorių persidengimo realizavimo strategijos, kopijavimo konstruktorius, priskyrimo ir kopijavimo konstruktoriaus palyginimas, konstruktorius, seklus ir gilus kopijavimas, „rule of 3” , „r-values“ nuorodos, „move“ semantika, “rule of 5”, “išmaniosios” rodyklės. | <ul><li> [slides/operatoriu-persidengimas.pdf](https://github.com/objprog/paskaitos/blob/master/slides/operatoriu-persidengimas.pdf) </li> <li> [slides/copy-move-semantika.pdf](https://github.com/objprog/paskaitos/blob/master/slides/copy-move-semantika.pdf) </li></ul> |
| 5. Kompozicija ir agregavimas, paveldėjimas, paveldėjimo kontrolė, konstruktoriai ir paveldėjima, polimorfizmas, virtualios funkcijos, ankstyvas ir vėlyvas binding’as, UML diagramos, dokumentacijos kūrimas su Doxygen. | <ul><li> [slides/paveldejimas.pdf](https://github.com/objprog/paskaitos/blob/master/slides/paveldejimas.pdf) </li></ul> |
| 6. Standartiniai išvesties ir įvesties srautai, failų srautai. | <ul><li> [slides/2-oji-praktine-uzduotis.pdf](https://github.com/objprog/paskaitos/blob/master/slides/2-oji-praktine-uzduotis.pdf)</li></ul> |
| 7. Klaidų ir išimčių valdymas, laiko matavimas (std::chrono biblioteka), atsitiktinių skaičių generavimas. | <ul><li> [slides/std-chrono.pdf](https://github.com/objprog/paskaitos/blob/master/slides/std-chrono.pdf)</li> <li>[std::chrono](https://github.com/objprog/paskaitos/wiki/std%3A%3Achrono)</li><li>[S.T. Lavavej: rand() Considered Harmful](http://video.ch9.ms/sessions/gonat/2013/STLGN13rand.pptx)</li></ul> |
| 8. Bendrinis programavimas, šablono klasės ir funkcijos. | <ul><li> </li></ul> |
| 9. Konteineriai (vektorius, dekas, sąrašas, žemėlapiai, hash lentelės ir t.t.), iteratoriai. Algoritmų apžvalga: efektyvumas su algoritmais, sparta su duomenų struktūromis. | <ul><li> [slides/vartotoju-tipai-klases.pdf](https://github.com/objprog/paskaitos/blob/master/slides/vartotoju-tipai-klases.pdf) </li> <li>[Konteinerių tipai](https://github.com/objprog/paskaitos/wiki/Konteineri%C5%B3-tipai)</li><li>[Ch. Carruth: "Efficiency with Algorithms, Performance with Data Structures"](https://www.youtube.com/watch?v=fHNmRkzxHWs)</li></ul> |
